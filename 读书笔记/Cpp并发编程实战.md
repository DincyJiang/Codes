gitbook地址：https://chenxiaowei.gitbooks.io/cpp_concurrency_in_action/content/

## 第1章 你好，C++的并发世界!

### 1.1 何谓并发

最简单和最基本的并发,是指两个或更多独立的活动同时发生。

#### 1.1.1 计算机系统中的并发

计算机领域的并发指的是在单个系统里同时执行多个独立的任务，而非顺序的进行一些活动。

任务切换：只有一个处理器的计算机只能在某一时刻执行一个任务，不过它可以每秒进行多次任务切换。通过“这个任务做一会，再切换到别的任务，再做一会儿”的方式，让任务看起来是并行执行的。任务切换会给用户和应用程序造成一种“并发的假象”。

硬件并发：多处理器计算机用于服务器和高性能计算已有多年。基于单芯多核处理器(多核处理器)的台式机，也越来越大众化。无论拥有几个处理器，这些机器都能够真正的并行多个任务。

#### 1.1.2 并发的途径

多进程并发

多线程并发（本书讨论）

### 1.2 为什么使用并发？

主要原因有两个：关注点分离(SOC)和性能。

#### 1.2.1 为了分离关注点

编写软件时，分离关注点是个好主意；通过将相关的代码与无关的代码分离，可以使程序更容易理解和测试，从而减少出错的可能性。

#### 1.2.2 为了性能

两种方式利用并发提高性能：

第一，将一个单个任务分成几部分，且各自并行运行，从而降低总运行时间。这就是任务并行（task parallelism）。

第二，每个线程在不同的数据部分上执行相同的操作。这就是数据并行（data parallelism）。

#### 1.2.3 什么时候不使用并发

基本上，不使用并发的唯一原因就是，收益比不上成本。

### 1.3 C++中的并发和多线程

只有在C++11标准下，才能编写不依赖平台扩展的多线程代码。

#### 1.3.1 C++多线程历史

C++98(1998)标准不承认线程的存在。有一些与平台无关的C++类库(例如:Boost和ACE)。缺乏统一标准的支持。

#### 1.3.2 新标准支持并发

#### 1.3.3 C++线程库的效率

在实现相同功能的前提下，直接使用底层API并不会带来过多的性能收益。

#### 1.3.4 平台相关的工具

C++线程库中提供一个native_handle()成员函数，允许通过使用平台相关API直接操作底层实现。

### 1.4 开始入门

#### 1.4.1 你好，并发世界

```c
#include <iostream>
#include <thread> // 管理线程的函数和类在<thread>中声明

void hello() { // 每个线程都必须具有一个初始函数(initial function)，新线程的执行从这里开始。
    std::cout << "Hello, Concurrent World" << std::endl;
}

int main() { // 对于应用程序来说，初始线程是main()
    std::thread t(hello); // std::thread对象 t 拥有新函数hello()作为其初始函数。
    t.join(); // 调用线程(在main()中)等待与std::thread对象 t 相关联的线程
    return 0;
}
```

### 1.5 本章总结

本章中，提及了并发与多线程的含义,以及在你的应用程序中为什么你会选择使用(或不使用)它。还提及了多线程在C++中的发展历程，从1998标准中完全缺乏支持，经历了各种平台相关的扩展，再到新的C++11标准中具有合适的多线程支持。芯片制造商选择了以多核心的形式，使得更多任务可以同时执行的方式来增加处理能力，而不是增加单个核心的执行速度。在这个趋势下，C++多线程来的正是时候，它使得程序员们可以利用新的CPU，带来的更加强大的硬件并发。

使用1.4节中例子，展示C++标准库中的类和函数有多么的简单。C++中使用多线程并不复杂，复杂的是如何设计代码以实现其预期的行为。

## 第2章 线程管理














