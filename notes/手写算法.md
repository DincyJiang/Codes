<!-- GFM-TOC -->
* [排序](#排序)
* [查找](#查找)
* [链表](#链表)
* [二叉树](#二叉树)
* [回溯算法](#回溯算法)
* [贪心算法](#贪心算法)
* [动态规划](#动态规划)
<!-- GFM-TOC -->

# 排序
[冒泡排序](#冒泡排序)、[选择排序](#选择排序)、[插入排序](#插入排序)、[希尔排序](#希尔排序)、[归并排序](#归并排序)、[快速排序](#快速排序)

从小到大排序

### 冒泡排序

从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。

在一轮循环中，如果没有发生交换，就说明数组已经是有序的，此时可以直接退出。

以下演示了在一轮循环中，将最大的元素 5 上浮到最右侧。

<div align="center"> <img src="../pics//1a2f2998-d0da-41c8-8222-1fd95083a66b.png" width="250"/> </div><br>

```c
void bubbleSort(vector<int> &nums) {
    int n = nums.size();
    for (int i = n - 1; i >= 0; --i)
        for (int j = 0; j < i; ++j)
            if (nums[j] > nums[j + 1])
                swap(nums[j], nums[j + 1]);
}
```

### 选择排序

选择出数组中的最小元素，将它与数组的第一个元素交换位置。再从剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。

选择排序需要 \~N<sup>2</sup>/2 次比较和 \~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。

<div align="center"> <img src="../pics//37e79a32-95a9-4503-bdb1-159527e628b8.png" width="250"/> </div><br>

```c
void selectSort(vector<int>& nums) {
    int n = nums.size();
    for (int i = 0; i < n; ++i) {
        int min_index = i;
        for (int j = i+1; j < n; ++j) {
            if (nums[j] < nums[min_index])
                min_index = j;
        }
        swap(nums[i], nums[min_index]);
    }
}
```

### 插入排序

每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。

对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量。

插入排序的复杂度取决于数组的初始顺序，如果数组已经部分有序了，逆序较少，那么插入排序会很快。

- 平均情况下插入排序需要 \~N<sup>2</sup>/4 比较以及 \~N<sup>2</sup>/4 次交换；
- 最坏的情况下需要 \~N<sup>2</sup>/2 比较以及 \~N<sup>2</sup>/2 次交换，最坏的情况是数组是倒序的；
- 最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。

以下演示了在一轮循环中，将元素 2 插入到左侧已经排序的数组中。

<div align="center"> <img src="../pics//2a8e1442-2381-4439-a83f-0312c8678b1f.png" width="250"/> </div><br>

```c
void insertSort(vector<int>& nums) {
    int n = nums.size();
    for (int i = 1; i < n; ++i) {
        int cur = nums[i];
        int j = i - 1;
        while (j >= 0 && nums[j] > cur) {
            nums[j+1] = nums[j];
            --j;
        }
        nums[j+1] = cur;
    }
}
```

### 归并排序

归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。

<div align="center"> <img src="../pics//220790c6-4377-4a2e-8686-58398afc8a18.png" width="350"/> </div><br>

```c
const int N = 100000;
void merge(vector<int>& vec, int l, int m, int r) {
    int n1 = m - l + 1; // 左边部分
    int n2 = r - m;     // 右边部分

    vector<int> l_vec(n1+1, 0);
    for (int i = 0; i != n1; ++i)
        l_vec[i] = vec[l + i];

    vector<int> r_vec(n2+1, 0);
    for (int i = 0; i != n2; ++i)
        r_vec[i] = vec[m + i + 1];
    
    l_vec[n1] = N; // 结尾加上一个超大的数字
    r_vec[n2] = N;

    int i = 0, j = 0;
    for (int k = l; k <= r; ++k) {
        if(l_vec[i] < r_vec[j])
            vec[k] = l_vec[i++];
        else
            vec[k] = r_vec[j++];
    }
}
void mergeSort(vector<int>& vec, int l, int r) {
    if (l < r) {
        int m = (l+r) / 2;
        mergeSort(vec, l, m);
        mergeSort(vec, m + 1, r);
        merge(vec, l, m, r);
    }
}
void mergeSort(vector<int>& vec) {
    int n = vec.size();
    mergeSort(vec, 0, n - 1);
}
```

### 快速排序

快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。

```c
void quickSort(vector<int>& nums, int lhs, int rhs) {
    if (lhs > rhs) return;
    int i = lhs+1, j = rhs, pivot = nums[lhs];
    while (i < j) {
        while (nums[j] >= pivot && i < j) --j;
        while (nums[i] <= pivot && i < j) ++i;
        if (i < j) swap(nums[i], nums[j]);
    }
    swap(nums[lhs], nums[i]);
    quickSort(nums, lhs, i-1);
    quickSort(nums, i+1, rhs);
}
void quickSort(vector<int>& nums) {
    int n = nums.size();
    quickSort(nums, 0, n-1);
}
```

# 查找

[二分查找](#二分查找)

* 查找和目标值相等的数

```c
int find(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size();
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;
        else if (nums[mid] < target) right = mid;
        else left = mid + 1;
    }
    return -1;
}
```

* 查找第一个不小于目标值的数，可变形为查找最后一个小于目标值的数

我们要查找的目标值不一定会在数组中出现，也有可能是跟目标值相等的数在数组中并不唯一，而是有多个，那么这种情况下nums[mid] == target这条判断语句就没有必要存在。

```c
int find(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size();
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) left = mid + 1;
        else right = mid;
    }
    return right;
}
```

这一类可以轻松的变形为查找最后一个小于目标值的数，怎么变呢。我们已经找到了第一个不小于目标值的数，那么再往前退一位，返回right - 1，就是最后一个小于目标值的数。

* 查找第一个大于目标值的数，可变形为查找最后一个不大于目标值的数

```c
int find(vector<int>& nums, int target) {
    int left = 0; 
    int right = nums.size();
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] <= target) left = mid + 1;
        else right = mid;
    }
    return left;
}
```

这一类可以轻松的变形为查找最后一个不大于目标值的数，怎么变呢。我们已经找到了第一个大于目标值的数，那么再往前退一位，返回right - 1，就是最后一个不大于目标值的数。

* 在排序数组中查找元素的第一个和最后一个位置

[LeetCode34](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。算法时间复杂度必须是 O(log n) 级别。

```c
vector<int> searchRange(vector<int>& nums, int target) {
    vector<int> res(2, -1);
    if (nums.empty())
        return res;
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target)
            left = mid + 1;
        else
            right = mid;
    }
    if (nums[right] != target)
        return res;
    res[0] = right;
    right = nums.size();
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] <= target)
            left = mid + 1;
        else
            right = mid;
    }
    res[1] = left - 1;
    return res;
}
```

# 链表

[反转链表I](#反转链表I)、[反转链表II](#反转链表II)、[环形链表I](#环形链表I)、[环形链表II](#环形链表II)、[删除链表中的重复元素I](#删除链表中的重复元素I)、[删除链表中的重复元素II](#删除链表中的重复元素II)、[删除链表中的节点I](#删除链表中的节点I)、[删除链表中的节点II](#删除链表中的节点II)、[相交链表](#相交链表)、[合并两个有序链表](#合并两个有序链表)、[两两交换链表中的节点](#两两交换链表中的节点)、[K个一组反转链表](#K个一组反转链表)、[分隔链表](#分隔链表)

### 反转链表I

[LeetCode206](https://leetcode-cn.com/problems/reverse-linked-list/)

反转一个单链表。

```c
ListNode* reverseList(ListNode* head) {
    ListNode *pre = nullptr;
    ListNode *cur = head;
    while (cur) {
        ListNode *next = cur->next;
        cur->next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```

### 反转链表II

[LeetCode92](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

```c
ListNode* reverseBetween(ListNode* head, int m, int n) {
    ListNode *dummy = new ListNode(-1);
    dummy->next = head;
    ListNode *cur = dummy;
    ListNode *pre = nullptr; // 反转段的前一个
    ListNode *front = nullptr; // 反转段反转之后的第一个
    ListNode *last = nullptr; // 反转段反转之后的最后一个
    for (int i = 1; i < m; ++i) cur = cur->next;
    pre = cur;
    last = cur->next;
    for (int i = m; i <= n; ++i) {
        cur = pre->next;
        pre->next = cur->next;
        cur->next = front;
        front = cur;
    }
    cur = pre->next;
    pre->next = front;
    last->next = cur;
    return dummy->next;
}
```

### 环形链表I

[LeetCode141](https://leetcode-cn.com/problems/linked-list-cycle/)

判断链表是否有环。

```c
bool hasCycle(ListNode *head) {
    ListNode *fast = head;
    ListNode *slow = head;
    while (fast && fast->next) {
        fast = fast->next->next;
        slow = slow->next;
        if (fast == slow)
            return true;
    }
    return false;
}
```

### 环形链表II

[LeetCode142](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回null。

说明：不允许修改给定的链表。

```c
ListNode *detectCycle(ListNode *head) {
    ListNode *fast = head;
    ListNode *slow = head;
    while (fast && fast->next) {
        fast = fast->next->next;
        slow = slow->next;
        if (fast == slow)
            break;
    }
    if (!fast || !fast->next)
        return nullptr; // 无环
    slow = head;        // 快慢指针相遇时，慢指针回到头节点
    while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }
    return slow;
}
```

### 删除链表中的重复元素I

[LeetCode83](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

```c
ListNode *deleteDuplicates(ListNode *head) {
    ListNode *cur = head;
    while (cur && cur->next) {
        if (cur->val == cur->next->val) {
            ListNode *delNode = cur->next;
            cur->next = cur->next->next;
            delete delNode;
            delNode = nullptr;
        }
        else
            cur = cur->next;
    }
    return head;
}
```

### 删除链表中的重复元素II

[LeetCode82](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中没有重复出现的数字。

```c
ListNode *deleteDuplicates(ListNode *head) {
    ListNode *dummy = new ListNode(-1);
    dummy->next = head;
    ListNode *pre = dummy;
    ListNode *cur = head;
    while (cur && cur->next) {
        ListNode *next = cur->next;
        if (cur->val == cur->next->val) {
            while (next && next->val == cur->val)
                next = next->next;
            pre->next = next;
            cur = next;
        } else {
            pre = cur;
            cur = next;
        }
    }
    return dummy->next;
}
```

### 删除链表中的节点I

[LeetCode237](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

```c
void deleteNode(ListNode *node) {
    ListNode *next = node->next;
    node->val = next->val;
    node->next = next->next;
    delete next;
    next = nullptr;
}
```

### 删除链表中的节点II

[LeetCode203](https://leetcode-cn.com/problems/remove-linked-list-elements/)

删除链表中等于给定值 val 的所有节点。

```c
ListNode *removeElements(ListNode *head, int val) {
    ListNode *dummy = new ListNode(-1);
    dummy->next = head;
    ListNode *cur = dummy;
    while (cur && cur->next) {
        if (cur->next->val == val) {
            ListNode *delNode = cur->next;
            cur->next = cur->next->next;
            delete delNode;
            delNode = nullptr;
        }
        else
            cur = cur->next;
    }
    return dummy->next;
}
```

### 相交链表

找到两个单链表相交的起始节点。

```c

```

### 合并两个有序链表

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

```c

```

### 两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

```c

```

### K个一组反转链表

给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。

```c

```

### 分隔链表

给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。

```c

```

# 二叉树

[前序遍历](#前序遍历)、[中序遍历](#中序遍历)、[后序遍历](#后序遍历)、[层序遍历](#层序遍历)、[翻转二叉树](#翻转二叉树)、[二叉搜索树的最近公共祖先](#二叉搜索树的最近公共祖先)、[二叉树的最近公共祖先](#二叉树的最近公共祖先)、[二叉树的最大深度](#二叉树的最大深度)、[二叉树的最小深度](#二叉树的最小深度)、[平衡二叉树](#平衡二叉树)、[二叉树的右视图](#二叉树的右视图)、[二叉树的下一个节点](#二叉树的下一个节点)

### 前序遍历

```c

```

### 中序遍历

```c

```

### 后序遍历

```c

```

### 层序遍历

```c

```

### 翻转二叉树

```c

```

### 二叉搜索树的最近公共祖先

```c

```

### 二叉树的最近公共祖先

```c

```

### 二叉树的最大深度

```c

```

### 二叉树的最小深度

```c

```

### 平衡二叉树

```c

```

### 二叉树的右视图

```c

```

### 二叉树的下一个节点

```c

```

# 回溯算法

[全排列](#全排列)、[组合](#组合)、[小岛的个数](#小岛的个数)

深度优先搜索

### 全排列

```c

```

### 组合

```c

```

### 小岛的个数

```c

```

# 贪心算法

[分发饼干](#分发饼干)

```c

```

# 动态规划

[斐波那契数列](#斐波那契数列)、[最长上升子序列](#最长上升子序列)、[最长公共子序列](#最长公共子序列)、[最长公共子串](#最长公共子串)

### 斐波那契数列

```c

```

### 最长上升子序列

```c

```

### 最长公共子序列

```c

```

### 最长公共子串

```c

```
