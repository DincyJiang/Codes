<!-- GFM-TOC -->
* [一、构建基本脚本](#一构建基本脚本)
    * [创建脚本文件](#创建脚本文件)
    * [显示消息](#显示消息)
    * [使用变量](#使用变量)
    * [重定向输入和输出](#重定向输入和输出)
    * [管道](#管道)
    * [执行数学运算](#执行数学运算)
    * [退出脚本](#退出脚本)
* [二、进程管理](#二进程管理)
    * [进程与线程](#进程与线程)
    * [进程状态的切换](#进程状态的切换)
    * [进程调度算法](#进程调度算法)
    * [进程同步](#进程同步)
    * [经典同步问题](#经典同步问题)
    * [进程通信](#进程通信)
* [三、死锁](#三死锁)
    * [必要条件](#必要条件)
    * [处理方法](#处理方法)
    * [鸵鸟策略](#鸵鸟策略)
    * [死锁检测与死锁恢复](#死锁检测与死锁恢复)
    * [死锁预防](#死锁预防)
    * [死锁避免](#死锁避免)
* [四、内存管理](#四内存管理)
    * [虚拟内存](#虚拟内存)
    * [分页系统地址映射](#分页系统地址映射)
    * [页面置换算法](#页面置换算法)
    * [分段](#分段)
    * [段页式](#段页式)
    * [分页与分段的比较](#分页与分段的比较)
* [五、设备管理](#五设备管理)
    * [磁盘结构](#磁盘结构)
    * [磁盘调度算法](#磁盘调度算法)
* [六、链接](#六链接)
    * [编译系统](#编译系统)
    * [静态链接](#静态链接)
    * [目标文件](#目标文件)
    * [动态链接](#动态链接)
* [参考资料](#参考资料)
<!-- GFM-TOC -->

# 一、构建基本脚本

### 创建脚本文件

在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为: #!/bin/bash。在通常的shell脚本中，井号(#)用作注释行。shell脚本文件的第一行是个例外，#后面的惊叹号会告诉shell用哪个shell来运行脚本。test1.sh：

```shell
#!/bin/bash
# This script displays the date and who's logged on
date
who
```

根据需要，使用分号将两个命令放在一行上，但在shell脚本中，你可以在独立的行中书写命令。shell会按根据命令在文件中出现的顺序进行处理。

shell会通过PATH环境变量来查找命令。查看PATH环境变量：

```shell
$ echo $PATH
```

PATH环境变量被设置成只在一组目录中查找命令。要让shell找到test1脚本，只需采取以下两种作法之一:

* 将shell脚本文件所处的目录添加到PATH环境变量中;

* 在提示符中用绝对或相对文件路径来引用shell脚本文件。

执行脚本：

```shell
$ ./test1.sh
bash: ./test1.sh: Permission denied
```

现在shell找到了脚本文件，但还有一个问题。shell指明了你还没有执行文件的权限。快速查看一下文件权限就能找到问题所在。

```shell
$ ls -l test1
-rw-rw-r--    1 user     user           73 Sep 24 19:56 test1
```

下一步是通过chmod命令赋予文件属主执行文件的权限：

```shell
$ chmod u+x test1.sh
$ ./test1.sh
Wed Nov 14 08:36:40 UTC 2018
```

### 显示消息

在echo命令后面加上了一个字符串，该命令就能显示出这个文本字符串。默认情况下，不需要使用引号将要显示的文本字符串划定出来。

```shell
#!/bin/bash
echo The time and date are:
```

echo命令可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们，你需要在文本中使用其中一种引号，而用另外一种来将字符串划定起来。

```shell
#!/bin/bash
echo "This is a test to see if you're paying attention"
echo 'Rich says "scripting is easy".'
```

把文本字符串和命令输出显示在同一行中，可以用echo语句的-n参数：你需要在字符串的两侧使用引号，保证要显示的字符串尾部有一个空格。命令输出将会在紧接着字符串结束的地方出现。

```shell
#!/bin/bash
echo -n "The time and date are: "
date
```

### 使用变量

#### 环境变量

shell维护着一组环境变量，用来记录特定的系统信息。比如系统的名称、登录到系统上的用户名、用户的系统ID(也称为UID)、用户的默认主目录以及shell查找程序的搜索路径。可以用set命令来显示一份完整的当前环境变量列表。

```shell
$ set
BASH=/bin/bash
HOME=/home/Samantha
```

在脚本中，可以在环境变量名称之前加上美元符($)来使用这些环境变量。

```shell
#!/bin/bash
# display user information from the system.
echo "User info for userid: $USER"
echo UID: $UID
echo HOME: $HOME
```

注意，echo命令中的环境变量会在脚本运行时替换成当前值。

只要脚本在引号中出现美元符，它就会以为你在引用一个变量。要显示美元符，你必须在它前面放置一个反斜线。

```shell
$ echo "The cost of the item is \$15"
The cost of the item is $15
```

${variable}形式引用的变量。变量名两侧额外的花括号通常用来帮助识别美元符后的变量名。

#### 用户变量

除了环境变量，shell脚本还允许在脚本中定义和使用自己的变量。

* 用户变量可以是任何由字母、数字或下划线组成的文本字符串，长度不超过20个。

* 用户变量区分大小写。

* 使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。

* shell脚本会自动决定变量值的数据类型。

* 与系统变量类似，用户变量可通过美元符引用。

```shell
#!/bin/bash
days=10
guest="Katie"
echo "$guest checked in $days days ago"
```

#### 命令替换

shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。

有两种方法可以将命令输出赋给变量，变量testing获得了date命令的输出:

* 反引号字符(`) 

```shell
#!/bin/bash
testing='date'
```

* $()格式

```shell
#!/bin/bash
testing=$(date)
```

下面这个例子很常见，它在脚本中通过命令替换获得当前日期并用它来生成唯一文件名：

```shell
#!/bin/bash
# copy the /usr/bin directory listing to a log file
today=$(date +%y%m%d)
ls /usr/bin -al > log.$today
```

这个脚本将日期值赋给一个变量，之后再将其作为文件名的一部分。文件自身含有目录列表的重定向输出。运行该脚本之后，应该能在目录中看到一个新文件。

```shell
-rw-r--r-- 1 user user 769 Jan 31 10:15 log.140131
```

目录中出现的日志文件采用$today变量的值作为文件名的一部分。日志文件的内容是/usr/bin目录内容的列表输出。

警告：命令替换会创建一个子shell来运行对应的命令。子shell(subshell)是由运行该脚本的shell 所创建出来的一个独立的子shell(child shell)。正因如此，由该子shell所执行命令是无法使用脚本中所创建的变量的。

### 重定向输入和输出

重定向可以用于输入，也可以用于输出。可以将命令的输出重定向到另一个位置(比如文件)，也可以将文件重定向到命令输入。

#### 输出重定向

最基本的重定向将命令的输出发送到一个文件中。bash shell用大于号(>)来完成这项功能。之前显示器上出现的命令输出会被保存到指定的输出文件中。

```shell
$ date > test
```

如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。可以用双大于号(>>)来追加数据。

```shell
$ date >> test6
```

#### 输入重定向

输入重定向将文件的内容重定向到命令，输入重定向符号是小于号(<)。

```shell
$ wc < test6
```

还有另外一种输入重定向的方法，称为内联输入重定向(inline input redirection)。这种方法无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据就可以了。内联输入重定向符号是远小于号(<<)。在命令行上使用内联输入重定向时，shell会用PS2环境变量中定义的次提示符(参见第6章) 来提示输入数据。下面是它的使用情况。

```shell
$ wc << EOF
> test string 1
> test string 2
> test string 3
> EOF
```

次提示符会持续提示，以获取更多的输入数据，直到你输入了作为文本标记的那个字符串。

### 管道

有时需要将一个命令的输出作为另一个命令的输入。这可以用重定向来实现，只是有些笨拙。我们用不着将命令输出重定向到文件中，可以将其直接重定向到另一个命令。这个过程叫作管道连接(piping)。

* 管道符号由两个竖线构成，一个在另一个上面。然而管道符号的印刷体通常看起来更像是单个竖线(|)。

* 不要以为由管道串起的两个命令会依次执行。Linux系统实际上会同时运行这两个命令，在系统内部将它们连接起来。在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据传输不会用到任何中间文件或缓冲区。

* 如果想要更别致点，也可以搭配使用重定向和管道来将输出保存到文件中。

* 管道最流行的用法之一是将命令产生的大量输出通过管道传送给more命令。

```shell
$ ls -al | more
```

### 执行数学运算

在shell脚本中有两种途径来进行数学运算。

#### expr命令

```shell
$ expr 1 + 5
6
```

许多expr命令操作符在shell中另有含义(比如星号)。当它们出现在在expr命令中时，会得到一些诡异的结果。要解决这个问题，对于那些容易被shell错误解释的字符，在它们传入expr命令之前，需要使用shell的转义字符(反斜线)将其标出来。

#### 使用方括号

在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号($[ operation ])将数学表达式围起来。

```shell
$ var1=$[1 + 5]
$ echo $var1
6
```

这种技术也适用于shell脚本。

```shell
#!/bin/bash
var1=100
var2=50
var3=45
var4=$[$var1 * ($var2 - $var3)]
echo The final result is $var4
```

bash shell数学运算符只支持整数运算。

#### 浮点解决方案

有几种解决方案能够克服bash中数学运算的整数限制。最常见的方案是用内建的bash计算器，叫作bc。

* bc的基本用法

bash计算器实际上是一种编程语言，它允许在命令行中输入浮点表达式，然后解释并计算该表达式，最后返回结果。

```shell
$ bc
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc. 13 This is free software with ABSOLUTELY NO WARRANTY.
For details type 'warranty'.
12 * 5.4
64.8
```

* 在脚本中使用bc

可以用命令替换运行bc命令，并将输出赋给一个变量。这个例子将scale变量设置成了四位小数，并在expression部分指定了特定的运算：

```shell
#!/bin/bash
var1=$(echo "scale=4; 3.44 / 5" | bc)
echo The answer is $var1
```

如果需要进行大量运算，在一个命令行中列出多个表达式就会有点麻烦。最好的办法是使用内联输入重定向，它允许你直接在命令行中重定向数据。在shell脚本中，可以将输出赋给一个变量。

```shell
#!/bin/bash
var1=10.46
var2=43.67
var3=33.2
var4=71
var5=$(bc << EOF
scale = 4
a1 = ( $var1 * $var2)
b1 = ($var3 * $var4)
a1 + b1
EOF
)
echo The final answer for this mess is $var5
```

### 退出脚本

shell中运行的每个命令都使用退出状态码(exit status)告诉shell它已经运行完毕。退出状态码是一个0~255的整数值，在命令结束运行时由命令传给shell。可以捕获这个值并在脚本中使用。

#### 查看退出状态码

Linux提供了一个专门的变量$?来保存上个已执行命令的退出状态码。对于需要进行检查的命令，必须在其运行完毕后立刻查看或使用$?变量。它的值会变成由shell所执行的最后一条命令的退出状态码。

```shell
$ date
Sat Jan 15 10:01:30 EDT 2014
$ echo $?
0
```

按照惯例，一个成功结束的命令的退出状态码是0。如果一个命令结束时有错误，退出状态码就是一个正数值。无效命令会返回一个退出状态码127。

```shell
$ asdfg
-bash: asdfg: command not found
$ echo $?
127
```

#### exit命令

默认情况下，shell脚本会以脚本中的最后一个命令的退出状态码退出。你可以改变这种默认行为，返回自己的退出状态码。exit命令允许你在脚本结束时指定一个退出状态码。当查看脚本的退出码时，你会得到作为参数传给exit命令的值。退出状态码最大只能是255，超过255的话，shell通过模运算得到这个结果。

```shell
#!/bin/bash
# testing the exit status
var1=10
var2=30
var3=$[$var1 + $var2]
echo The answer is $var3
exit 5
```




